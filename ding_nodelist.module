<?php
/**
 * @file
 * Helps creating customizable lists of content
 * that can be placed on a panel.
 */

define('NL_CUSTOM', 'custom');
define('NL_DYNAMIC', 'dynamic');

define('NL_WIDGET_LIST', 'simple');
define('NL_WIDGET_CAROUSEL', 'carousel');
define('NL_WIDGET_ACCORDEON', 'accordeon');

define('NL_COL_FULL', 'full');
define('NL_COL_HALF', 'half');
define('NL_COL_THIRD', 'third');
define('NL_COL_QRT', 'quarter');

define('NL_TPL_ACTIVE', 0);
define('NL_TPL_HIDDEN', 1);

/**
 * Implements hook_menu().
 */
function ding_nodelist_menu() {
  $items = array();

  $items['admin/config/ding/ding_nodelist'] = array(
    'title' => 'Ding nodelist',
    'description' => 'View and customize lists of content.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ding_nodelist_settings_form'),
    'access arguments' => array('configure nodelist'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'ding_nodelist.admin.inc'
  );

  $items['admin/config/ding/ding_nodelist/settings'] = array(
    'title' => 'Settings',
    'description' => 'Configure general settings.',
    'tab_parent' => 'admin/config/ding/ding_nodelist',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'ding_nodelist.admin.inc'
  );

  $items['admin/config/ding/ding_nodelist/templates'] = array(
    'title' => 'Templates',
    'description' => 'Manage content templates.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ding_nodelist_templates_form'),
    'access arguments' => array('configure nodelist'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'ding_nodelist.admin.inc'
  );

  $items['ding_nodelist/autocomplete/%'] = array(
    'page callback' => 'ding_nodelist_autocomplete',
    'page arguments' => array(2),
    // @todo: implements permissions for nodelist managements
    //'access arguments' => array('create nodelist instances'),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function ding_nodelist_permission() {
  return array(
    'configure nodelist' => array(
      'title' => t('Configure nodelist'),
      'description' => t('Configure the behavior of nodelist'),
    ),
    // @todo: this permission is declared but not implemented.
//    'create nodelist instances' => array(
//      'title' => t('Manage nodelist instances'),
//      'description' => t('Create/edit/delete nodelist instances'),
//    ),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 * This lets ctools know to scan the module for a content_type plugin file.
 */
function ding_nodelist_ctools_plugin_directory($module, $plugin) {
  // we'll be nice and limit scandir() calls
  if ($module == 'ctools' && $plugin == 'content_types') {
    return 'plugins/content_types';
  }
}

/**
 * Ctools plugin callback for settings form.
 */
function ding_nodelist_content_type_edit_form($form, &$form_state) {

  // Cache the form for correct workflow.
  $form_state['cache'] = TRUE;

  $conf = $form_state['conf'];
  drupal_add_js(drupal_get_path('module', 'ding_nodelist') . '/js/admin.js', 'file');

  // Show only allowed content types.
  $node_types = variable_get('ding_nodelist_node_types', array());
  $all_node_types = node_type_get_names();
  foreach ($node_types as $nt => $active) {
    if ($active) {
      $node_types_opts[$nt] = $all_node_types[$nt];
    }
  }

  if (empty($node_types_opts)) {
    drupal_set_message(t('No eligible content types were found, please configure a few first.'), 'error', FALSE);
  }

  $node_type = isset($conf['content_type']) ? $conf['content_type'] : current(array_keys($node_types));

  $default_conf = array(
    'content_type' => $node_type,
    'list_type' => NL_CUSTOM,
    'widget_type' => NL_WIDGET_LIST,
    'columns' => NL_COL_FULL,
    'sort_field' => 'created',
    'sort_order' => 'desc',
    'more_text' => t('More'),
    'more_link' => '',
    'teaser_length' => 100,
  );

  $form['#prefix'] = '<div id="ding_nodelist-form-wrapper">';
  $form['#suffix'] = '</div>';

  /**
   * Initial settings.
   */
  $form['ding_nodelist_basic'] = array(
    '#type' => 'fieldset',
    '#collapsible' => FALSE,
    '#tree' => FALSE,
    '#title' => t('Basic settings'),
    '#collapsible' => FALSE,
    '#weight' => -4,
  );

  $form['ding_nodelist_basic']['content_type'] = array(
    '#type' => 'select',
    '#title' => t('Content type'),
    '#required' => TRUE,
    '#default_value' => $node_type,
    '#options' => $node_types_opts,
    '#description' => t('Select the content type of the list\'s items.'),
    '#ajax' => array(
      'wrapper' => 'ding_nodelist-selected-nodes',
      'callback' => 'ding_nodelist_js',
      'method' => 'replace',
      'effect' => 'fade'
    ),
  );

  $form['ding_nodelist_basic']['list_type'] = array(
    '#type' => 'radios',
    '#title' => t('List type'),
    '#description' => t('What kind of list you want to create.'),
    '#required' => TRUE,
    '#options'  => array(NL_CUSTOM => t(NL_CUSTOM), NL_DYNAMIC => t(NL_DYNAMIC)),
    '#default_value' => isset($conf['list_type']) ? $conf['list_type'] : $default_conf['list_type'],
  );

  $form['ding_nodelist_basic']['title_text'] = array(
    '#type' => 'textfield',
    '#title' => t('List title'),
    '#description' => t('Enter a title to be shown above the list items. Leave empty to omit the title.'),
    '#required' => FALSE,
    '#default_value' => isset($conf['title_text']) ? $conf['title_text'] : '',
  );

  /**
   * Manually controlled list.
   */
  $form['ding_nodelist_nodes'] = array(
    '#type' => 'fieldset',
    '#collapsible' => FALSE,
    '#tree' => FALSE,
    '#title' => t('Custom item list'),
    '#description' => t('Select the content of the list'),
    '#collapsible' => FALSE,
    '#prefix' => '<div class="clear-block" id="ding_nodelist-wrapper">',
    '#suffix' => '</div>',
    '#weight' => -3,
  );

  $form['ding_nodelist_nodes']['content_type_select'] = array(
    '#type' => 'submit',
    '#value' => t('Choose'),
    '#weight' => -2,
    '#submit' => array('ding_nodelist_add_node_submit'),
    '#ajax' => array(
      'callback' => 'ding_nodelist_js',
      'method' => 'replace',
      'effect' => 'fade'
    ),
    '#attributes' => array(
      'style' => 'display:none;',
    ),

  );

  // Render selected nodes.
  $form['ding_nodelist_nodes']['selected_nodes'] = array(
    '#prefix' => '<div id="ding_nodelist-selected-nodes">',
    '#suffix' => '</div>',
    '#theme' => '_ding_nodelist_items_table',
    '#tree' => TRUE,
    '#weight' => -1,
  );

  $delta = 0;
  $weight = 0;
  $max_weight = $weight;
  $node_count = NULL;
  $filter_count = NULL;

  // Check if form is ment to be rebuild thanks to an ajax request from the select element
  if (!empty($form_state['triggering_element']) && $form_state['triggering_element']['#name'] == 'content_type') {
    // Reset node and filter count.
    $node_count = 1;
    $filter_count = 1;

    // Refresh CT setting.
    $node_type = $form_state['triggering_element']['#value'];

    // Reset other form values.
    $conf['content_type'] = $node_type;
    $conf['selected_nodes'] = array();
    $conf['taxonomy_filters'] = array();

    $form_state['values']['content_type'] = $node_type;
    $form_state['values']['selected_nodes'] = array();
    $form_state['values']['taxonomy_filters'] = array();

    $form_state['conf']['content_type'] = $node_type;
    $form_state['conf']['selected_nodes'] = array();
    $form_state['conf']['taxonomy_filters'] = array();

    unset($form_state['input']['content_type']);
    unset($form_state['input']['selected_nodes']);
    unset($form_state['input']['taxonomy_filters']);

    // Rebuild the form.
    $form_state['rebuild'] = TRUE;
    $form_state['#dn_ct_changed'] = TRUE;
  }

  if (is_null($node_count)) {
    if (isset($form_state['values']['selected_nodes_count'])) {
      $node_count = $form_state['values']['selected_nodes_count'];
    }
    else {
      $node_count = empty($form_state['values']['selected_nodes']) ? 1 : count($form_state['values']['selected_nodes']);
    }
  }

  if (isset($conf['selected_nodes']) && count($conf['selected_nodes'])
        && isset($conf['content_type']) && ($conf['content_type'] == $conf['selected_nodes'][0]['type'])) {
    $delta = count($conf['selected_nodes']);
    foreach ($conf['selected_nodes'] as $key => $node) {
      $weight = $node['weight'];
      $max_weight = ($max_weight < $weight) ? $weight : $max_weight;
      $form['ding_nodelist_nodes']['selected_nodes'][$key] = _ding_nodelist_selected_node($key, $node_type, $node, $weight);
    }
  }

  // Add new node field.
  $weight = ++$max_weight;
  for (; $delta < $node_count; $delta ++) {
    $key = $delta;
    $form['ding_nodelist_nodes']['selected_nodes'][$key] = _ding_nodelist_selected_node($key, $node_type, NULL, $weight);
  }

  $form['ding_nodelist_nodes']['add_node'] = array(
    '#type' => 'submit',
    '#value' => t('Add content'),
    '#weight' => 1,
    '#submit' => array('ding_nodelist_add_node_submit'),
    '#ajax' => array(
      'wrapper' => 'ding_nodelist-selected-nodes',
      'callback' => 'ding_nodelist_js_add_node',
      'method' => 'replace',
      'effect' => 'fade'
    ),
  );

  /**
   * Dynamic list settings.
   */
  $form['ding_nodelist_dynamic'] = array(
    '#type' => 'fieldset',
    '#title' => t('Dynamic list'),
    '#required' => FALSE,
    '#weight' => -2,
  );

  // Render selected filters.
  $form['ding_nodelist_dynamic']['taxonomy_filters'] = array(
    '#type'   => 'fieldset',
    '#title'  => t('Taxonomy filters'),
    '#description' => t('Create one or more taxonomy filters. The content selected will match all of them.'),
    '#prefix' => '<div id="ding_nodelist-taxonomy-filters">',
    '#suffix' => '</div>',
    '#theme' => '_ding_nodelist_filters_table',
    '#tree' => TRUE,
    '#weight' => -1,
  );

  if (is_null($filter_count)) {
    if (isset($form_state['values']['taxonomy_filters_count'])) {
      $filter_count = $form_state['values']['taxonomy_filters_count'];
    }
    else {
      $filter_count = empty($form_state['values']['taxonomy_filters']) ? 1 : count($form_state['values']['taxonomy_filters']);
    }
  }

  // Retrieve vocabularies current CT references.
  $allowed_fields = array();
  $field_vocabulary = array();
  $fields = field_info_instances('node', $node_type);
  foreach ($fields as $field) {
    $field_config = field_info_field($field['field_name']);
    // Check if the field is a term reference field.
    if ($field_config['type'] == 'taxonomy_term_reference') {
      $allowed_fields[$field['field_name']] = $field['label'];
      $field_vocabulary[$field['field_name']] = $field_config['settings']['allowed_values'][0]['vocabulary'];
    }
  }

  // Check if filter vocabulary was changed.
  $changed_filter_id = NULL;
  if (!empty($form_state['triggering_element']) && isset($form_state['triggering_element']['#parents'][2])
          && $form_state['triggering_element']['#parents'][2] == 'filter_field') {
    $changed_filter_id = $form_state['triggering_element']['#parents'][1];
    $changed_filter = $form_state['values']['taxonomy_filters'][$changed_filter_id];
    // @todo: do not allow to change to empty value on frontend - provide a 'delete' button instead.
    if (!empty($changed_filter['filter_field'])) {
      // Update auto-complete, preserve other fields.
      $filter['filter_field'] = $changed_filter['filter_field'];
      $filter['filter_vocab'] = $field_vocabulary[$filter['filter_field']];

      // Important: delete old input!
      unset($form_state['input']['taxonomy_filters'][$changed_filter_id]);
      $form_state['#dn_filter_changed'] = TRUE;
      $form['ding_nodelist_dynamic']['taxonomy_filters'][$changed_filter_id] = _ding_nodelist_taxonomy_filter($allowed_fields, $filter, $changed_filter_id);
    }
  }

  $delta = 0;

  // @todo: improve the check.
  if (isset($conf['taxonomy_filters']) && isset($conf['content_type'])) {
    $delta = count($conf['taxonomy_filters']);
    foreach ($conf['taxonomy_filters'] as $key => $filter) {
      if ($changed_filter_id === $key) {
        continue;
      }

      $tags = array();
      foreach ($filter['filter_terms'] as $tid) {
        $tags[$tid] = taxonomy_term_load($tid);
      }
      $filter['filter_terms'] = taxonomy_implode_tags($tags);
      $filter['filter_vocab'] = $field_vocabulary[$filter['filter_field']];
      $form['ding_nodelist_dynamic']['taxonomy_filters'][$key] = _ding_nodelist_taxonomy_filter($allowed_fields, $filter, $key);
    }
  }

  // Add new filter field.
  for (; $delta < $filter_count; $delta++) {
    $key = $delta;
    if ($changed_filter_id === $key) {
      continue;
    }
    $form['ding_nodelist_dynamic']['taxonomy_filters'][$key] = _ding_nodelist_taxonomy_filter($allowed_fields, NULL, $key);
  }

  $form['ding_nodelist_dynamic']['add_filter'] = array(
    '#type' => 'submit',
    '#value' => t('Add filter'),
    '#weight' => 0,
    '#submit' => array('ding_nodelist_add_filter_submit'),
    '#ajax' => array(
      'wrapper' => 'ding_nodelist-taxonomy-filters',
      'callback' => 'ding_nodelist_js_add_filter',
      'method' => 'replace',
      'effect' => 'fade'
    ),
  );

  /**
   * Content filters.
   */
  /*
  $form['ding_nodelist_dynamic']['content_filters'] = array(
    '#type'   => 'fieldset',
    '#title'  => t('Content filters'),
    '#weight' => 1,

    'content_filter_promoted' => array(
      '#type' => 'checkbox',
      '#title' => t('Show "Promoted to front page" content'),
      '#description' => t('Only promoted content will be shown'),
      '#default_value' => isset($conf['content_filter_promoted']) ? $conf['content_filter_promoted'] : FALSE,
    ),

    'content_filter_sticky' => array(
      '#type' => 'checkbox',
      '#title' => t('Show sticky content'),
      '#description' => t('Sticky content will be shown first'),
      '#default_value' => isset($conf['content_filter_sticky']) ? $conf['content_filter_sticky'] : FALSE,
    )
  );
  */
  /**
   * Display settings.
   */
  $form['ding_nodelist_display'] = array(
    '#type' => 'fieldset',
    '#title' => t('Display settings'),
    '#collapsible' => FALSE,
    '#description' => t('Define custom visualization settings'),
  );

  // Set up all the available view modes for this type of nodes.
  $entity = entity_get_info('node');
  $node_formats = array();
  foreach ($entity['view modes'] as $view_mode => $settings) {
    $node_formats[$view_mode] = $settings['label'];
  }

  $widget_types = array(
    NL_WIDGET_LIST      => t('Simple list'),
  // @todo: implement.
//    NL_WIDGET_CAROUSEL  => t('Carousel'),
//    NL_WIDGET_ACCORDEON => t('Accordeon'),
  );

  $form['ding_nodelist_display']['widget_type'] = array(
    '#type' => 'select',
    '#title' => t('List type'),
    '#required' => TRUE,
    '#default_value' => isset($conf['widget_type']) ? $conf['widget_type'] : $default_conf['widget_type'],
    '#options' => $widget_types,
    '#description' => t('If single item selected, only the first item will be rendered')
  );

  $item_templates = _ding_nodelist_get_templates(FALSE, $node_type);
  $tpl_options = array();
  foreach ($item_templates as $filename => $template) {
    $tpl_options[$filename] = empty($template['title']) ? $filename : $template['title'];
  }
  $form['ding_nodelist_display']['item_template'] = array(
    '#type' => 'select',
    '#title' => t('Item template'),
    // @todo: cannot make it require since it may be empty and fail validation
    // on any ajax submit (ct change, filter update etc.)
    '#required' => FALSE,
    '#default_value' => isset($conf['item_template']) ? $conf['item_template'] : '',
    '#options' => $tpl_options,
    '#description' => t('Choose a template responsible for item display mode')
  );

  $form['ding_nodelist_display']['columns'] = array(
    '#type' => 'select',
    '#title' => t('Width (columns)'),
    '#options' => array(
      NL_COL_FULL   => t('full width'),
      NL_COL_HALF   => '1/2',
      NL_COL_THIRD  => '1/3',
      NL_COL_QRT    => '1/4'
    ),
    '#default_value' => isset($conf['columns']) ? $conf['columns'] : $default_conf['columns']
  );

  $form['ding_nodelist_display']['sort_field'] = array(
    '#type' => 'select',
    '#title' => t('Sort by'),
    '#options' => array(
      'created' => t('creation date'),
      'title'   => t('title'),
    ),
    '#default_value' => isset($conf['sort_field']) ? $conf['sort_field'] : $default_conf['sort_field']
  );

  // @todo: place next to Sort by field ie in one row (better UX).
  $form['ding_nodelist_display']['sort_order'] = array(
    '#type' => 'select',
    '#title' => t('Sorting order'),
    '#options' => array(
      'asc' => t('ascending'),
      'desc'=> t('descending'),
    ),
    '#default_value' => isset($conf['sort_order']) ? $conf['sort_order'] : $default_conf['sort_order']
  );

  // Forms for Bottom settings.
  $form['ding_nodelist_bottom_links'] = array(
    '#type' => 'fieldset',
    '#title' => t('Bottom links'),
    '#collapsible' => FALSE,
    '#description' => t('Custom title text for "More" botton links'),
    '#weight' => -1,  
  );

  // Container for bottom links
  $form['ding_nodelist_bottom_links']['more_links'] = array(
    '#prefix' => '<div id="ding_nodelist-more-link">',
    '#suffix' => '</div>',
    '#theme' => '_ding_nodelist_links_table',
    '#tree' => TRUE,
    '#weight' => -1,
  );

  // Get all bottom links.
  $delta = 0;
  $weight = 0;
  $max_weight = $weight;

  if (isset($form_state['values']['bottom_links_count'])) {
    $links_count = $form_state['values']['bottom_links_count'];
  }
  else {
    $links_count = empty($form_state['values']['more_links']) ? 1 : count($form_state['values']['more_links']);
  }

  if (isset($conf['more_links'])) {
  	$delta = count($conf['more_links']);
    foreach ($conf['more_links'] as $key => $link) {
      $weight = $link['weight'];
      $max_weight = ($max_weight < $weight) ? $weight : $max_weight;
      $form['ding_nodelist_bottom_links']['more_links'][$key] = _ding_nodelist_links_form($key, $link);
    }
  }

  // Add new bottom link field.
  $weight = ++$max_weight;
  for ($delta; $delta < $links_count; $delta ++) {
    $key = $delta;
    $form['ding_nodelist_bottom_links']['more_links'][$key] = _ding_nodelist_links_form($key, NULL);
  }

  $form['ding_nodelist_bottom_links']['ding_bottom_links_more'] = array(
    '#type' => 'submit',
    '#value' => t('Add more link'),
    '#weight' => 1,
    '#submit' => array('ding_nodelist_more_bottom_link_submit'),
    '#ajax' => array(
      'wrapper' => 'ding_nodelist-more-link',
      'callback' => 'ding_nodelist_js_add_links',
      'effect' => 'fade',
      'method' => 'replace',
    ),
  );  

  // Use custom title options.
  unset($form['override_title']);
  unset($form['override_title_text']);
  return $form;
}

function _ding_nodelist_selected_node($key, $type, $node = NULL, $weight = 0) {
  $form = array(
    '#tree' => TRUE,
    '#weight' => $weight,
  );

  // Set default value for 'node'
  $node_default =  (!is_null($node) && isset($node['node'])) ? $node['node'] : '';
  $form['node'] = array(
    '#type' => 'textfield',
    '#title' => t('Select new node to add to list'),
    '#title_display' => 'invisible',
    '#autocomplete_path' => 'ding_nodelist/autocomplete/' . $type,
    '#parents' => array('selected_nodes', $key, 'node'),
    '#default_value' => $node_default,
  );

  $form['nid'] = array(
    '#type' => 'value',
    '#value' => NULL,
    '#parents' => array('selected_nodes', $key, 'nid'),
  );

  // Set default value for 'nid' if not empty field
  if (!is_null($node) && isset($node['nid']) && ctype_digit($node['nid'])) {
    $form['nid']['#value'] = $node['nid'];
  }
  elseif (!is_null($node) && isset($node['node'])) {
    $tmp_node = explode(':', $node['node']); // EXPERIMENTAL FIX! previous value '$node' gave warnings.
    $tmp_node = array_pop($tmp_node);
    $tmp_node = substr($tmp_node, 0, -1);
    if (ctype_digit($tmp_node)) {
      $node['nid'] = $tmp_node;
    }
  }

  $form['type'] = array(
    '#type' => 'value',
    '#value' => $type,
    '#parents' => array('selected_nodes', $key, 'type'),
  );

  $form['weight'] = array(
    '#type' => 'weight',
    '#title' => $node['nid'] !== '' ? t('Weight for node @label', array('@label' => $node['nid'])) : t('Weight for new choice'),
    '#title_display' => 'invisible',
    '#default_value' => $weight,
    '#delta' => 50,
    '#parents' => array('selected_nodes', $key, 'weight'),
  );

  return $form;
}

/**
 * Builds more link form.
 */
function _ding_nodelist_links_form($key, $link) {
  $form = array(
    '#tree' => TRUE,
    '#weight' => $key,
  );

  $form['text'] = array(
    '#type' => 'textfield',
    '#title' => 'More link text',
    '#title_display' => 'invisible',
    '#size' => 20,     
    '#tree' => TRUE,
    '#weight' => -1,
    '#parents' => array('more_links', $key, 'text'),
    '#default_value' => (!empty($link['text'])) ? $link['text'] : '',
  );

  $form['links'] = array(
    '#type' => 'textfield',
    '#title' => t('"More" button link'),
    '#title_display' => 'invisible',  
    '#required' => FALSE,
    '#description' => t('Enter local Drupal path or external URL starting with http(s).'),
    '#parents' => array('more_links', $key, 'links'),
    '#default_value' => (!empty($link['links'])) ? $link['links'] : '',     
  );

  return $form;
}

/**
 * Builds filter form.
 */
function _ding_nodelist_taxonomy_filter($fields, $filter, $key) {
  $form = array(
    '#tree' => TRUE,
    '#weight' => $key
  );

  $form['filter_field'] = array(
    '#type' => 'select',
    '#title_display' => 'invisible',
    '#empty_option' => t('-- select --'),
    '#options' => $fields,
    '#default_value' => !is_null($filter) && !empty($filter['filter_field']) ? $filter['filter_field'] : '',
    '#ajax' => array(
      'wrapper' => 'ding_nodelist-taxonomy-filters',
      'callback' => 'ding_nodelist_js_add_filter',
      'method' => 'replace',
      'effect' => 'fade'
    ),
    '#parents' => array('taxonomy_filters', $key, 'filter_field'),
  );

  $form['filter_terms'] = array(
    '#vocabulary_name'=> $filter['filter_vocab'],
    '#type' => 'textfield',
    '#title_display' => 'invisible',
    '#default_value' => !is_null($filter) && !empty($filter['filter_terms']) ? $filter['filter_terms'] : '',
    '#parents' => array('taxonomy_filters', $key, 'filter_terms'),
    '#maxlength' => 1024,
    '#element_validate' => array('_ding_nodelist_taxonomy_autocomplete_validate'),
    '#autocomplete_path' => !is_null($filter) && !empty($filter['filter_field'])
      ? 'taxonomy/autocomplete/' . $filter['filter_field'] : NULL,
  );

  return $form;
}

/**
 * Custom submit function to add more choices
 */
function ding_nodelist_add_node_submit(&$form, &$form_state) {
  // Add new node to list.
  if ($form_state['values']['op'] == $form_state['values']['add_node']) {
    $form_state['values']['selected_nodes_count'] = count($form_state['values']['selected_nodes']) + 1;

    unset($form_state['input']['selected_nodes']);
  }

  // Change node types.
  if ($form_state['values']['op'] == $form_state['values']['content_type_select']) {
    foreach ($form_state['values']['selected_nodes'] as $key => $node) {
      if (($node['type'] != $form_state['values']['content_type'])) {
        unset($form_state['values']['selected_nodes'][$key]);
      }
    }

    // Removing empty nodes.
    foreach ($form_state['values']['selected_nodes'] as $key => $node) {
      if (empty($node['node'])) {
        unset($form_state['values']['selected_nodes'][$key]);
      }
    }

    unset($form_state['input']['selected_nodes']);
    unset($form_state['input']['content_type']);
  }

  foreach ($form_state['values']['selected_nodes'] as $key => $node) {
    if (!empty($node['node'])) {
      $tmp_nid = explode(':', $node['node']);
      $tmp_nid = array_pop($tmp_nid);
      $tmp_nid = substr($tmp_nid, 0, -1);
      // TODO: Implement more complex check for given title + ID
      if (ctype_digit($tmp_nid)) {
        $form_state['values']['selected_nodes'][$key]['nid'] = $tmp_nid;
      }
    }
  }

  // Saving all the values of the form.
  _ding_nodelist_content_type_form_save($form_state, TRUE);
}

/**
 * Custom submit function for adding more filters.
 */
function ding_nodelist_add_filter_submit(&$form, &$form_state) {
  // Add new filter.
  if ($form_state['values']['op'] == $form_state['values']['add_filter']) {
    $form_state['values']['taxonomy_filters_count'] = count($form_state['values']['taxonomy_filters']) + 1;

    unset($form_state['input']['taxonomy_filters']);
  }

  // Saving all the values of the form.
  _ding_nodelist_content_type_form_save($form_state, TRUE);
}

/**
 * Custom submit function for adding more links.
 */
function ding_nodelist_more_bottom_link_submit(&$form, &$form_state) {
  // Add new link to list.
  if ($form_state['values']['op'] == $form_state['values']['ding_bottom_links_more']) {
    $form_state['values']['bottom_links_count'] = count($form_state['values']['more_links']) + 1;

    unset($form_state['input']['more_links']);
  }

  // Saving all the values of the form.
  _ding_nodelist_content_type_form_save($form_state, TRUE);

}

/**
 * Edit form validate function.
 */
function ding_nodelist_content_type_edit_form_validate($form, &$form_state) {
  // Do not validate on certain ajax requests.
  if (!empty($form_state['#dn_ct_changed']) || !empty($form_state['#dn_filter_changed'])) {
    // Unset ajax request flags to ensure further validation.
    unset($form_state['#dn_filter_changed']);
    unset($form_state['#dn_ct_changed']);
    return;
  }

  // Validating selected nodes
  if ($form_state['values']['list_type'] == NL_CUSTOM && (!count($form_state['values']['selected_nodes'])
          || empty($form_state['values']['selected_nodes'][0]['node']))) {
    form_set_error('nodes', t('No nodes were selected.'));
  }

  // Remove empty/partially set filters.
  if ($form_state['values']['list_type'] == NL_DYNAMIC) {
    foreach ($form_state['values']['taxonomy_filters'] as $key => $filter) {
      if (empty($filter['filter_field']) && empty($filter['filter_terms'])) {
        unset($form_state['values']['taxonomy_filters'][$key]);
      }

      // Check if some filters are not fully completed.
      if (!isset($form_state['#dn_filter_changed'])) {
        if (empty($filter['filter_terms'])) {
          form_set_error("taxonomy_filters][$key][filter_terms", t('No terms specified for filter.'));
        }
      }
    }

    // Check if there are any non-empty filters.
    if (!count($form_state['values']['taxonomy_filters'])) {
      form_set_error('taxonomy_filters', t('You need to specify at least one filter.'));
    }
  }

  foreach ($form_state['values']['more_links'] as $key => $bottom) {
    if (empty($bottom['text'])) {
      unset($form_state['values']['more_links'][$key]);
    }

    if (!drupal_valid_path($bottom['links'])) {
      if (!valid_url($bottom['links'], TRUE)) {
        form_set_error("more_links][$key][links", t('External links must begin with "http" or "https".'));
      }
    }
    // Handles <front>
    if ($bottom['links'] == '<front>') {
      if (isset($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) == 'on'){
        $bottom['links'] = 'https://' . $_SERVER['SERVER_NAME'] . '/';
      } else {
        $bottom['links'] = 'http://' . $_SERVER['SERVER_NAME'] . '/';
        }
    }     
  }
 
  // Validate template selection.
  if (empty($form_state['values']['item_template'])) {
    form_set_error('item_template', t('Please select item template.'));
  }
}

/**
 * Edit form submit function.
 */
function ding_nodelist_content_type_edit_form_submit($form, &$form_state) {

  // Removing empty nodes
  foreach ($form_state['values']['selected_nodes'] as $key => $node) {
    if (empty($node['node'])) {
      unset($form_state['values']['selected_nodes'][$key]);
    }
    else {
      $tmp_nid = explode(':', $node['node']);
      $tmp_nid = array_pop($tmp_nid);
      $tmp_nid = substr($tmp_nid, 0, -1);
      // TODO: Implement more complex check for correct title of the given ID
      if (ctype_digit($tmp_nid)) {
        $form_state['values']['selected_nodes'][$key]['nid'] = $tmp_nid;
      }
    }
  }

  // Removing empty filters.
  foreach ($form_state['values']['taxonomy_filters'] as $key => $filter) {
    if (empty($filter['filter_field']) || empty($filter['filter_terms'])) {
      unset($form_state['values']['taxonomy_filters'][$key]);
    }
  }

  // Anything in $form_state['conf'] will be saved automatically.
  _ding_nodelist_content_type_form_save($form_state);
}

/**
 * Ajax handler of content type select box.
 * Returns multiple commands.
 */
function ding_nodelist_js($form, &$form_state) {
  return array(
    '#type' => 'ajax',
    '#commands' => array(
      ajax_command_replace('#ding_nodelist-selected-nodes', drupal_render($form['ding_nodelist_nodes']['selected_nodes'])),
      ajax_command_replace('#ding_nodelist-taxonomy-filters', drupal_render($form['ding_nodelist_dynamic']['taxonomy_filters'])),
      ajax_command_replace('.form-item-item-template', drupal_render($form['ding_nodelist_display']['item_template'])),
    )
  );
}

/**
 * Ajax handler of bottom links actions.
 */
function ding_nodelist_js_add_links($form, &$form_state) {
  return $form['ding_nodelist_bottom_links']['more_links'];
}

/**
 * Ajax handler for custom nodes actions.
 */
function ding_nodelist_js_add_node($form, &$form_state) {
  return $form['ding_nodelist_nodes']['selected_nodes'];
}

/**
 * Ajax handler of taxonomy filter actions.
 */
function ding_nodelist_js_add_filter($form, &$form_state) {
  return $form['ding_nodelist_dynamic']['taxonomy_filters'];
}

/**
 * Autocomplete function that gives the available nodes
 */
function ding_nodelist_autocomplete($type = FALSE, $title = '') {
  $nodes = array();

  $result = db_query("SELECT nid, title FROM {node} WHERE type = :type AND title LIKE :title", array(':type' => $type, ':title' => '%' . $title . '%'));
  $nodes = $result->fetchAllKeyed();

  // Make a beatifull select.
  $formatted_result = array();
  foreach ($nodes as $nid => $title) {
    $formatted_result[$title . " [nid:$nid]"] = $title;
  }

  drupal_json_output($formatted_result);
}

/**
 * Implements hook_theme().
 */
function ding_nodelist_theme($existing, $type, $theme, $path) {
  // Do not rely on path - it may be unknown to module_invoke_all caller.
  $path = drupal_get_path('module', 'ding_nodelist') . '/templates';

  $themes = array(
    // Configuration form templates.
    '_ding_nodelist_items_table' => array(
      'render element' => 'form',
    ),
    '_ding_nodelist_filters_table' => array(
      'render element' => 'form',     
    ),
    '_ding_nodelist_links_table' => array(
      'render element' => 'form',     
    ),
    '_ding_nodelist_templates_table' => array(
      'render element' => 'form',
    ),
    // Widget templates.
    '_ding_nodelist_widget_simple' => array(
      'path' => $path,
      'template' => 'ding_nodelist_widget_simple',
      'variables' => array('items' => NULL, 'links' => NULL, 'conf' => NULL),
    ),
    '_ding_nodelist_widget_carousel' => array(
      'path' => $path,
      'template' => 'ding_nodelist_widget_carousel',
      'variables' => array('items' => NULL, 'links' => NULL, 'conf' => NULL),
    ),
    '_ding_nodelist_widget_accordeon' => array(
      'path' => $path,
      'template' => 'ding_nodelist_widget_accordeon',
      'variables' => array('items' => NULL, 'links' => NULL, 'conf' => NULL),
    ),
    // List item templates.
    'ding_nodelist.ding_event.image_text' => array(
      'path' => $path,
      'template' => 'ding_nodelist.ding_event.image_text',
      'variables' => array('item' => NULL, 'conf' => NULL),
    ),
    'ding_nodelist.article_editorial_dashboard.image_text' => array(
      'path' => $path,
      'template' => 'ding_nodelist.article_editorial_dashboard.image_text',
      'variables' => array('item' => NULL, 'conf' => NULL),
    ),
    'ding_nodelist.event_editorial_dashboard.image_text' => array(
      'path' => $path,
      'template' => 'ding_nodelist.event_editorial_dashboard.image_text',
      'variables' => array('item' => NULL, 'conf' => NULL),
    ),
    'ding_nodelist.ding_news.image_text' => array(
      'path' => $path,
      'template' => 'ding_nodelist.ding_news.image_text',
      'variables' => array('item' => NULL, 'conf' => NULL),
    ),
    'ding_nodelist.ding_news.text' => array(
      'path' => $path,
      'template' => 'ding_nodelist.ding_news.text',
      'variables' => array('item' => NULL, 'conf' => NULL),
    ),
  );

  return $themes;
}

/**
 * Helper theming function
 */
function theme__ding_nodelist_items_table($variables) {
  $form = $variables['form'];

  drupal_add_tabledrag('ding_nodelist-selected-table', 'order', 'sibling', 'ding_nodelist-weight');

  $is_admin = user_access('administer nodes');
  $delta = 0;
  $rows = array();
  $headers = array('', t('Selected content'));
  $headers[] = t('Weight');

  foreach (element_children($form) as $key) {
    $delta++;
    // Set special classes for drag and drop updating.
    $form[$key]['weight']['#attributes']['class'] = array('ding_nodelist-weight');

    // Build the table row.
    $row = array(
      'data' => array(
        array('class' => array('choice-flag')),
        drupal_render($form[$key]['node']),
      ),
      'class' => array('draggable'),
    );
    $row['data'][] = drupal_render($form[$key]['weight']);

    // Add any additional classes set on the row.
    if (!empty($form[$key]['#attributes']['class'])) {
      $row['class'] = array_merge($row['class'], $form[$key]['#attributes']['class']);
    }

    $rows[] = $row;
  }

  $output = theme('table', array('header' => $headers, 'rows' => $rows, 'attributes' => array('id' => 'ding_nodelist-selected-table')));
  $output .= drupal_render_children($form);
  return $output;
}

/**
 * Helper theming function
 */
function theme__ding_nodelist_filters_table($variables) {
  $form = $variables['form'];

  $rows = array();
  $header = array(t('Field'), t('Values'));

  foreach (element_children($form) as $key) {
    // Build the table row.
    $row = array(
      'data' => array(
        drupal_render($form[$key]['filter_field']),
        drupal_render($form[$key]['filter_terms']),
      ),
    );

    $rows[] = $row;
  }

  $output = theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => 'ding_nodelist-filters-table')));
  $output .= drupal_render_children($form);
  return $output;
}

/**
 * Helper theming function
 */
function theme__ding_nodelist_links_table($variables) {
  $form = $variables['form'];
  $rows = array();
  $header = array(t('Text'), t('Links'));

  foreach (element_children($form) as $key) {
    // Build the table row.
    $row = array(
      'data' => array(
        drupal_render($form[$key]['text']),
        drupal_render($form[$key]['links']),
      ),
    );

    $rows[] = $row;
  }

  $output = theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => 'ding_nodelist-links-table')));
  $output .= drupal_render_children($form);
  return $output;
}

/**
 * Theme function to render the backend list of templates.
 */
function theme__ding_nodelist_templates_table($variables) {
  $header = array(
    t('Machine name'),
    t('Title'),
    t('Content type'),
    t('Visible'),
  );
  $rows = array();
  $form = $variables['form'];
  foreach (element_children($form) as $key) {
    $rows[] = array(
      $form[$key]['template_name']['#value'],
      drupal_render($form[$key]['title']),
      drupal_render($form[$key]['content_type']),
      drupal_render($form[$key]['visible']),
    );
  }

  return theme('table', array('header' => $header, 'rows' => $rows));
}

/**
 * Ctools admin view pane's title.
 */
function ding_nodelist_content_type_admin_title($subtype, $conf, $context = NULL) {
  if (!empty($conf['title_text'])) {
    $output = t('Nodelist') . ': ' . filter_xss_admin($conf['title_text']);
  }
  else {
    $output = t('Nodelist (untitled)');
  }
  return $output;
}

/**
 * Callback to provide administrative info (the preview in panels when building
 * a panel).
 */
function ding_nodelist_content_type_admin_info($subtype, $conf, $context = NULL) {
  // @todo: show details about nodelist configuration here.
  $block->title = t('No information');
  $info = '';
  $block->content = $info;
  return $block;
}

/**
 * Run-time rendering of the body of the list.
 *
 * @param $subtype Content type sub-type
 * @param $conf Configuration as done at admin time.
 * @param $args
 * @param $context
 *
 * @return
 *   An object with at least title and content members.
 */
function ding_nodelist_content_type_render($subtype, $conf, $args, $context) {

  $block = new stdClass();

  // Prepare classes for widget container.
  $columns = $conf['columns'];
  $classes = array();
  $classes[] = 'ding_nodelist';
  $classes[] = 'ding_nodelist-' . $conf['widget_type'];
  $classes[] = 'ding_nodelist-col-' . $columns;

  // Build title
  $title = NULL;
  if (!empty($conf['title_text'])) {
    $title = check_plain($conf['title_text']);
  }

  // Build 'More' link.
  $more = '';
  foreach ($conf['more_links'] as $key => $bottom) {
    $link_bottom[$key] =l(t($bottom['text']), $bottom['links']);
  }
  $more_links = theme('item_list', array('items' =>$link_bottom));

  // Define if this is the last column pane and apply additional style.
  $map = _ding_nodelist_get_column_map();
  $columns_layout = &drupal_static('ding_nodelist_cols', array());
  if (empty($columns_layout[$columns])) {
    $columns_layout[$columns] = 1;
    $classes[] = 'ding_nodelist-col-first';
  }
  else {
    $columns_layout[$columns]++;
  }
  if ($columns_layout[$columns] == $map[$columns]) {
    $classes[] = 'ding_nodelist-col-last';
    $columns_layout[$columns] = 0;
  }

  // Load default CSS.
  drupal_add_css(drupal_get_path('module', 'ding_nodelist') . '/css/ding_nodelist.css', 'file');
  // Special JS for carousel widget.
  if ($conf['widget_type'] == NL_WIDGET_CAROUSEL) {
    $add_carousel_js = &drupal_static(__FUNCTION__ . '_js', TRUE);
    if ($add_carousel_js) {
      drupal_add_js(drupal_get_path('module', 'ding_nodelist') . '/js/jquery.carouFredSel-4.4.2.js', 'file');
      drupal_add_js(drupal_get_path('module', 'ding_nodelist') . '/js/carousel.js', 'file');
      $add_carousel_js = FALSE;
    }
  }
  // @todo: special JS for accordeon widget.

  // Render the contents.
  if ($conf['list_type'] == NL_CUSTOM) {
    $nodes = _ding_nodelist_get_custom_list_nodes($conf);
  }
  elseif ($conf['list_type'] == NL_DYNAMIC) {
    $nodes = _ding_nodelist_get_dynamic_list_nodes($conf);
  }

  // Render individual items.
  $nodes = node_load_multiple($nodes);
  $rendered_nodes = '';
  foreach ($nodes as $node) {
    $rendered_nodes .= theme($conf['item_template'], array('item' => $node));
  }

  $theme_func = '_ding_nodelist_widget_' . $conf['widget_type'];
  $block->content = theme($theme_func, array(
    'items' => $rendered_nodes,
    'links' => $more_links,
    'conf' => array(
      'title' => $title,
      'classes' => join(' ', $classes)
    )));

  return $block;
}

/**
 * Returns the most up-to-date list of nodelist templates.
 * @param   boolean   include or not hidden templates in return array
 * @return  array found nodelist template details
 */
function _ding_nodelist_get_templates($include_hidden = TRUE, $content_type = NULL) {
  static $templates = array();

  if (!empty($templates)) {
    return $templates;
  }

  // Fetch templates declared by this and other modules (hook_theme templates).
  // @todo: menu_block is known to cause issues on this call in PHP 5.3.x.
  foreach (module_invoke_all('theme', array(), NULL, NULL, NULL) as $template_name => $template) {
    if (strpos($template_name, 'ding_nodelist') === 0) {
      $templates[$template_name] = array(
        'filename' => $template_name,
      );
    }
  }

  $db_templates =
    db_select('ding_nodelist_templates', 'dnt')->fields('dnt')
      ->execute()->fetchAllAssoc('filename', PDO::FETCH_ASSOC);
  $db_template_names = array_keys($db_templates);

  // Register new templates.
  foreach ($templates as $template_name => $template) {
    if (!in_array($template_name, $db_template_names)) {
      $tpl_record = array(
        'filename'  => $template_name,
        'title'     => $template_name,
        'status'    => NL_TPL_HIDDEN  // @todo: show nodelist's native templates by default?
      );
      try {
        db_insert('ding_nodelist_templates')->fields($tpl_record)->execute();
      }
      catch (Exception $e) {
        // @todo: show errors when template name duplicates an existing.
      }
    }
  }

  // Second, collect templates from db and find the common list.
  $db_templates =
  db_select('ding_nodelist_templates', 'dnt')->fields('dnt')
    ->execute()->fetchAllAssoc('filename', PDO::FETCH_ASSOC);

  foreach ($db_templates as $template_name => $template) {
    // Do not include hidden templates.
    if (!$include_hidden) {
      if ($template['status'] == NL_TPL_HIDDEN) {
        unset($templates[$template_name]);
        continue;
      }
    }

    if (isset($templates[$template_name])) {
      // Fetch content type from filename.
      $ct_name = explode('.', $template_name);
      if (!$content_type || ($content_type && $content_type == $ct_name[1])) {
        $templates[$template_name] = $template;
        $templates[$template_name]['content_type'] = $ct_name[1];
      }
      else {
        unset($templates[$template_name]);
      }
    }
    // Template exists in DB but is not declared - remove it.
    else {
      db_delete('ding_nodelist_templates')->condition('filename', $template_name)
        ->execute();
    }
  }

  ksort($templates);

  return $templates;
}

/**
 * Save CT plugin form values.
 */
function _ding_nodelist_content_type_form_save(&$form_state, $rebuild = FALSE) {

  $form_state['conf']['content_type'] = $form_state['values']['content_type'];
  $form_state['conf']['list_type'] = $form_state['values']['list_type'];
  $form_state['conf']['title_text'] = $form_state['values']['title_text'];
  $form_state['conf']['selected_nodes'] = $form_state['values']['selected_nodes'];
  $form_state['conf']['taxonomy_filters'] = $form_state['values']['taxonomy_filters'];
  $form_state['conf']['columns'] = $form_state['values']['columns'];
  $form_state['conf']['widget_type'] = $form_state['values']['widget_type'];
  $form_state['conf']['item_template'] = $form_state['values']['item_template'];
  $form_state['conf']['sort_field'] = $form_state['values']['sort_field'];
  $form_state['conf']['sort_order'] = $form_state['values']['sort_order'];
  $form_state['conf']['more_links'] = $form_state['values']['more_links'];

  if ($rebuild) {
    $form_state['rebuild'] = TRUE;
  }
}

/**
 * Retreive all nodes based on dynamic list settings.
 * @return array of node IDs
 */
function _ding_nodelist_get_dynamic_list_nodes($conf) {
  $nodes = array();

  if (isset($conf['taxonomy_filters']) && count($conf['taxonomy_filters'])) {
    // Support for slave-master DB servers.
    $query = db_select('node', 'n', array('target' => 'slave'))->fields('n', array('nid'));
    $ti_l = 'ti';
    $query->join('taxonomy_index', $ti_l, "n.nid = $ti_l.nid");
    $i = 1;
    foreach ($conf['taxonomy_filters'] as $filter) {
      $ti_r = 'ti' . $i++;
      $filter['filter_terms'] = is_array($filter['filter_terms']) ?
        $filter['filter_terms'] : array($filter['filter_terms']);
      // Use $i in argument placeholder as workaround.
      $ti_l = $query->join('taxonomy_index', $ti_r, "$ti_l.nid = $ti_r.nid AND $ti_r.tid IN (:tids$i)", array(":tids$i" => $filter['filter_terms']));
    }

    // Filter by content type/node settings.
    $query->condition('n.type', $conf['content_type'])
          ->condition('n.status', NODE_PUBLISHED)
          ->distinct();

    // Sorting.
    $query->orderBy('n.' . $conf['sort_field'], $conf['sort_order']);

    $nodes = $query->execute()->fetchCol();
  }

  return $nodes;
}

/**
 * Retreive all nodes based on custom list settings.
 * @return array of node IDs
 */
function _ding_nodelist_get_custom_list_nodes($conf) {
  $nodes = array();

  if (isset($conf['selected_nodes']) && count($conf['selected_nodes'])) {
    foreach ($conf['selected_nodes'] as $key => $node) {
      $nodes[$node['weight']] = $node['nid'];
    }
    // Sort the nodes according to their weight.
    ksort($nodes);
  }

  return $nodes;
}

/**
 * Customized function for taxononmy autocomplete element validation
 * (copied from core's taxonomy_autocomplete_validate)
 * @see taxonomy_autocomplete_validate
 */
function _ding_nodelist_taxonomy_autocomplete_validate($element, &$form_state) {
  // Autocomplete widgets do not send their tids in the form, so we must detect
  // them here and process them independently.
  $value = array();
  if ($tags = $element['#value']) {
    // Collect candidate vocabularies.
    $vocabularies = array();
    $vocabulary = taxonomy_vocabulary_machine_name_load($element['#vocabulary_name']);
    $vocabularies[$vocabulary->vid] = $vocabulary;

    // Translate term names into actual terms.
    $typed_terms = drupal_explode_tags($tags);
    foreach ($typed_terms as $typed_term) {
      // See if the term exists in the chosen vocabulary and return the tid;
      // otherwise, create a new 'autocreate' term for insert/update.
      if ($possibilities = taxonomy_term_load_multiple(array(), array('name' => trim($typed_term), 'vid' => array_keys($vocabularies)))) {
        $term = array_pop($possibilities);
      }
      else {
        form_error($element, t('Invalid term(s).'));
        return;
      }
      $value[] = (int)$term->tid;
    }
  }

  form_set_value($element, $value, $form_state);
}

/**
 * Translates constant definitions to numbers.
 */
function _ding_nodelist_get_column_map() {
  return array(
    NL_COL_FULL   => 1,
    NL_COL_HALF   => 2,
    NL_COL_THIRD  => 3,
    NL_COL_QRT    => 4,
  );
}
